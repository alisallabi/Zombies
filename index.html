
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>3D Zombie City Game</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
  #scoreboard {
    position: fixed; top: 10px; left: 10px; color: white; font-family: Arial, sans-serif; font-size: 20px; z-index: 10;
  }
</style>
</head>
<body>
<div id="scoreboard">Score: 0</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
let scene, camera, renderer, controls;
let player, zombies = [], civilians = [], bullets = [];
let loader = new THREE.GLTFLoader();

let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
let velocity = new THREE.Vector3();
let direction = new THREE.Vector3();

let score = 0;
const scoreText = document.getElementById('scoreboard');

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Ø£Ø±Ø¶ÙŠØ© Ø§Ù„Ù…Ø¯ÙŠÙ†Ø©
  const floorGeometry = new THREE.PlaneGeometry(100, 100);
  const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = - Math.PI / 2;
  scene.add(floor);

  // Ù…Ø¨Ø§Ù†ÙŠ Ø¨Ø³ÙŠØ·Ø© (Ù…ÙƒØ¹Ø¨Ø§Øª)
  for(let i = -40; i <= 40; i += 20){
    for(let j = -40; j <= 40; j += 20){
      if(Math.random() > 0.6){
        const bHeight = 5 + Math.random()*15;
        const buildingGeometry = new THREE.BoxGeometry(10, bHeight, 10);
        const buildingMaterial = new THREE.MeshStandardMaterial({color: 0x444444});
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        building.position.set(i, bHeight/2, j);
        scene.add(building);
      }
    }
  }

  // Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(10, 20, 10);
  scene.add(directionalLight);
  scene.add(new THREE.AmbientLight(0x404040));

  // ØªØ­ÙƒÙ… Ø§Ù„ÙØ£Ø±Ø©
  controls = new THREE.PointerLockControls(camera, document.body);
  document.body.addEventListener('click', () => { controls.lock(); });
  scene.add(controls.getObject());

  // ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ù„Ø§Ø¹Ø¨ 3D ÙƒØ±ØªÙˆÙ†ÙŠ (Ù…ÙˆØ¯ÙŠÙ„ low-poly)
  loader.load('https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Avocado/glTF/Avocado.gltf', gltf => {
    player = gltf.scene;
    player.scale.set(0.5,0.5,0.5);
    player.position.set(0, 0, 0);
    scene.add(player);
  });

  // ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ Ø²ÙˆÙ…Ø¨ÙŠ
  loader.load('https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Zombie/glTF/Zombie.gltf', gltf => {
    for(let i=0; i<5; i++){
      const zombie = gltf.scene.clone();
      zombie.scale.set(0.01, 0.01, 0.01);
      zombie.position.set((Math.random()-0.5)*80, 0, (Math.random()-0.5)*80);
      scene.add(zombie);
      zombies.push(zombie);
    }
  });

  // ØªØ­Ù…ÙŠÙ„ Ù†Ù…ÙˆØ°Ø¬ Ù…Ø¯Ù†ÙŠ Ø¨Ø³ÙŠØ·
  loader.load('https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Avocado/glTF/Avocado.gltf', gltf => {
    for(let i=0; i<3; i++){
      const civilian = gltf.scene.clone();
      civilian.scale.set(0.3,0.3,0.3);
      civilian.position.set((Math.random()-0.5)*80, 0, (Math.random()-0.5)*80);
      scene.add(civilian);
      civilians.push({
        model: civilian,
        direction: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize()
      });
    }
  });

  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);
  window.addEventListener('resize', onWindowResize);
  window.addEventListener('click', shoot);
}

function onKeyDown(event){
  switch(event.code){
    case 'KeyW': moveForward=true; break;
    case 'KeyS': moveBackward=true; break;
    case 'KeyA': moveLeft=true; break;
    case 'KeyD': moveRight=true; break;
  }
}
function onKeyUp(event){
  switch(event.code){
    case 'KeyW': moveForward=false; break;
    case 'KeyS': moveBackward=false; break;
    case 'KeyA': moveLeft=false; break;
    case 'KeyD': moveRight=false; break;
  }
}
function onWindowResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function shoot(){
  if(!controls.isLocked) return;
  const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
  const bulletMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
  const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
  bullet.position.copy(player.position);
  bullet.position.y += 1;
  const directionVector = new THREE.Vector3(0,0,-1);
  directionVector.applyQuaternion(camera.quaternion);
  bullet.userData = {velocity: directionVector.multiplyScalar(1)};
  scene.add(bullet);
  bullets.push(bullet);
}
function animate(){
  requestAnimationFrame(animate);
  if(!player) return;
  velocity.x -= velocity.x * 0.1;
  velocity.z -= velocity.z * 0.1;
  direction.z = Number(moveForward) - Number(moveBackward);
  direction.x = Number(moveRight) - Number(moveLeft);
  direction.normalize();
  if(moveForward || moveBackward) velocity.z -= direction.z * 0.05;
  if(moveLeft || moveRight) velocity.x -= direction.x * 0.05;
  player.position.x += velocity.x;
  player.position.z += velocity.z;
  camera.position.lerp(new THREE.Vector3(
    player.position.x,
    player.position.y + 5,
    player.position.z + 10
  ), 0.1);
  camera.lookAt(player.position);
  zombies.forEach((zombie, i) => {
    let dirX = player.position.x - zombie.position.x;
    let dirZ = player.position.z - zombie.position.z;
    let dist = Math.sqrt(dirX*dirX + dirZ*dirZ);
    if(dist > 0){
      dirX /= dist;
      dirZ /= dist;
    }
    zombie.position.x += dirX * 0.02;
    zombie.position.z += dirZ * 0.02;
    if(dist < 1){
      alert("ðŸ’€ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! Ù†ØªÙŠØ¬ØªÙƒ: " + score);
      window.location.reload();
    }
  });
  civilians.forEach(civ => {
    civ.model.position.addScaledVector(civ.direction, 0.01);
    if(Math.random() < 0.01){
      civ.direction.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
    }
    zombies.forEach(zombie => {
      if(civ.model.position.distanceTo(zombie.position) < 5){
        let fleeDir = new THREE.Vector3().subVectors(civ.model.position, zombie.position).normalize();
        civ.model.position.addScaledVector(fleeDir, 0.05);
      }
    });
  });
  bullets.forEach((bullet, i) => {
    bullet.position.add(bullet.userData.velocity);
    if(Math.abs(bullet.position.x) > 50 || Math.abs(bullet.position.z) > 50){
      scene.remove(bullet);
      bullets.splice(i,1);
      return;
    }
    zombies.forEach((zombie, zi) => {
      if(bullet.position.distanceTo(zombie.position) < 0.8){
        scene.remove(zombie);
        zombies.splice(zi,1);
        scene.remove(bullet);
        bullets.splice(i,1);
        score++;
        scoreText.textContent = "Score: " + score;
      }
    });
  });
  renderer.render(scene, camera);
}
</script>
</body>
</html>
